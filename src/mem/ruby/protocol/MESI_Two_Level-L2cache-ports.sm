/*
 * Copyright (c) 2020 ARM Limited
 * All rights reserved
 *
 * The license below extends only to copyright in the software and shall
 * not be construed as granting a license to any other intellectual
 * property including but not limited to intellectual property relating
 * to a hardware implementation of the functionality of the software
 * licensed hereunder.  You may use the software subject to the license
 * terms below provided that you ensure that this notice is replicated
 * unmodified and in its entirety in all distributions of the software,
 * modified or unmodified, in source code or in binary form.
 *
 * Copyright (c) 1999-2013 Mark D. Hill and David A. Wood
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L2Cache, "MESI Directory L2 Cache CMP")
 : CacheMemory * L2cache;
   CacheMemory * SF;
   Cycles l2_request_latency := 20;
   Cycles l2_response_latency := 20;
   Cycles to_l1_latency := 20;

   bool backup_L2_en := "false";
   Addr debugAddr := 0; 

  // Message Queues
  // From local bank of L2 cache TO the network
  MessageBuffer * DirRequestFromL2Cache, network="To", virtual_network="0",
    vnet_type="request";  // this L2 bank -> Memory

  MessageBuffer * L1RequestFromL2Cache, network="To", virtual_network="2",
    vnet_type="request";  // this L2 bank -> a local L1

  MessageBuffer * responseFromL2Cache, network="To", virtual_network="1",
    vnet_type="response";  // this L2 bank -> a local L1 || Memory

  // FROM the network to this local bank of L2 cache
  MessageBuffer * unblockToL2Cache, network="From", virtual_network="2",
    vnet_type="unblock";  // a local L1 || Memory -> this L2 bank

  MessageBuffer * L1RequestToL2Cache, network="From", virtual_network="0",
    vnet_type="request";  // a local L1 -> this L2 bank

  MessageBuffer * responseToL2Cache, network="From", virtual_network="1",
    vnet_type="response";  // a local L1 || Memory -> this L2 bank

  MessageBuffer * TriggerPort; // internal port for request pend
{
  // STATES
  state_declaration(State, desc="L2 Cache states", default="L2Cache_State_NP") {
    // Base states
    NP, AccessPermission:Invalid, desc="Not present in either cache";
    SS, AccessPermission:Read_Only, desc="L2 cache entry Shared, also present in one or more L1s";
    M, AccessPermission:Read_Write, desc="L2 cache entry Modified, not present in any L1s", format="!b";
    MT, AccessPermission:Maybe_Stale, desc="L2 cache entry Modified in a local L1, assume L2 copy stale, similar to E", format="!b";

    // L2 replacement
    M_I, AccessPermission:Busy, desc="L2 cache replacing, have all acks, sent dirty data to memory, waiting for ACK from memory";
    I_I, AccessPermission:Busy, desc="L2 replacing clean data, need to inv sharers and then drop data";
    S_I, AccessPermission:Busy, desc="L2 replacing dirty data, collecting acks from L1s";

    // Transient States for fetching data from memory
    ISS, AccessPermission:Busy, desc="L2 idle, got single L1_GETS, issued memory fetch, have not seen response yet";
    IS, AccessPermission:Busy, desc="L2 idle, got L1_GET_INSTR or multiple L1_GETS, issued memory fetch, have not seen response yet";
    IM, AccessPermission:Busy, desc="L2 idle, got L1_GETX, issued memory fetch, have not seen response(s) yet";

    // Blocking states
    SS_MB, AccessPermission:Busy, desc="Blocked for L1_GETX from SS";
    MT_MB, AccessPermission:Busy, desc="Blocked for L1_GETX from MT";

    MT_IIB, AccessPermission:Busy, desc="Blocked for L1_GETS from MT, waiting for unblock and data";
    MT_IB, AccessPermission:Busy, desc="Blocked for L1_GETS from MT, got unblock, waiting for data";
    MT_SB, AccessPermission:Busy, desc="Blocked for L1_GETS from MT, got data,  waiting for unblock";

    // cache in backup
    BK, AccessPermission:Busy, desc="cache line is received for directory, only for cache line state";
  }

  // EVENTS
  enumeration(Event, desc="L2 Cache events") {
    // L2 events

    // events initiated by the local L1s
    L1_GET_INSTR,            desc="a L1I GET INSTR request for a block maped to us";
    L1_GETS,                 desc="a L1D GETS request for a block maped to us";
    L1_GETS_withC,           desc="GETS request hit cache entry";
    L1_GETX,                 desc="a L1D GETX request for a block maped to us";
    L1_UPGRADE,              desc="a L1D GETX request for a block maped to us";
    L1_UPGRADE_BK,           desc="a L1D GETX request for a block maped to us";
    L1_UPGRADE_BKL2,         desc="a L1D GETX request for a block maped to us, bk to l2";

    L1_GET_INSTR_BK,         desc="a L1I GET INSTR request for a block maped to us, bk";
    L1_GETS_BK,              desc="a L1D GETS request for a block maped to us, bk";
    L1_GETX_BK,              desc="a L1D GETX request for a block maped to us, bk";

    L1_GET_INSTR_BKL2,       desc="a L1I GET INSTR request for a block maped to us, bk to l2";
    L1_GETS_BKL2,            desc="a L1D GETS request for a block maped to us, bk to l2";
    L1_GETX_BKL2,            desc="a L1D GETX request for a block maped to us, bk to l2";

    L1_PUTX_front,           desc="L1 replacing data, front";
    L1_PUTX_front_BK,        desc="L1 replacing data, front, bk";
    L1_PUTX_front_BK_cachefull, desc="L1 replacing data, front, bk, cache is full";
    L1_PUTX_BKL2,            desc="L1 replacing data, front, bk to l2";
    L1_PUTX_end,             desc="L1 replacing data, end";
    L1_PUTX_end_toMT,        desc="L1 replacing data, end to MT state";
    L1_PUTX_end_toSS,        desc="L1 replacing data, end to SS state";
    L1_PUTX_clean,           desc="L1 replacing clean data";
    L1_PUTX_clean_BK,        desc="L1 replacing clean data, bk";
    L1_PUTX_clean_toM,       desc="L1 replacing clean data to M state";
    L1_PUTX_clean_toNP,      desc="L1 replacing clean data to NP state";
    L1_PUTX_clean_pop,       desc="L1 replacing clean data, only pop queue";
    //L1_PUTX_old,             desc="L1 replacing data, but no longer sharer";

    // events initiated by this L2
    L2_Replacement,          desc="L2 Replacement", format="!r";
    //L2_Replacement_clean,    desc="L2 Replacement, but data is clean", format="!r";

    // SF eviction event
    SF_Replacement,          desc="SF Replacement", format="!r";
    SF_Replacement_withC,    desc="SF Replacement with cache", format="!r";
    SF_Switch,               desc="SF switch to cache as back up", format="!r";

    // events from memory controller
    Mem_Data,                desc="data from memory", format="!r";
    Mem_Data_IM,             desc="data from memory", format="!r";
    Mem_Data_ISS,            desc="data from memory", format="!r";
    Mem_Ack,                 desc="ack from memory to NP", format="!r";
    Mem_Ack_MT,              desc="ack from memory to MT", format="!r";
    Mem_Ack_SS,              desc="ack from memory to SS", format="!r";
    Mem_Ack_No_deallocTBE,   desc="ack from memory to BK", format="!r";

    // M->S data writeback
    WB_Data,                 desc="data from L1";
    WB_Data_Keep,            desc="data from L1, but keep I_I state";
    WB_Data_clean,           desc="clean data from L1";
    WB_Data_all,             desc="data from L1";
    Ack,                     desc="writeback ack";
    Ack_all,                 desc="writeback ack";
    Ack_all_DtoMem,          desc="writeback ack, but need to send data to mem";

    Unblock,                 desc="Unblock from L1 requestor";
    Unblock_Keep,            desc="Unblock from L1 requestor, but keep MT_SB state";
    Exclusive_Unblock,       desc="Unblock from L1 requestor";

    MEM_Inv,                 desc="Invalidation from directory";

    Pend,                    desc="pend request in event";
    Pop_ReqIn,               desc="event to pop request in port";
  }

  // TYPES

  // CacheEntry
  structure(CacheEntry, desc="...", interface="AbstractCacheEntry") {
    State CacheState,          desc="cache state";
    DataBlock DataBlk,       desc="data for the block";
    bool Dirty, default="false", desc="data is dirty";
    bool aheadAllocate, default="false", desc="allocate ahead";
    Addr aheadAddr, desc="Ahead addr";

    //bool isBackup, default="true", desc="entry is directory backup";
  }

  // DirEntry
  structure(DirEntry, desc="...", interface="AbstractCacheEntry", main="false") {
    State DirState,          desc="cache state";
    NetDest Sharers,               desc="tracks the L1 shares on-chip";
    MachineID Exclusive,          desc="Exclusive holder of block";
    bool waitEvict, default="false", desc="wait other victim evicts";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr addr,            desc="Physical address for this TBE";
    State TBEState,             desc="Transient state";
    DataBlock DataBlk,          desc="Buffer for the data block";
    bool Dirty, default="false", desc="Data is Dirty";
    bool dataBackInvalid, default="false", desc="back invalid data need to allocate";
    bool cacheToEvict, default="false", desc="directory entry tends to evict";
    bool dirToEvict, default="false", desc="directory entry tends to evict";
    bool hasSendDataToMem, default="false", desc="send only in t_sendDataToMem";
    bool hasprofileBIDirty,default="false", desc="counter flag for back invalidation dirty";

    NetDest L1_GetS_IDs,            desc="Set of the internal processors that want the block in shared state";
    MachineID L1_GetX_ID,          desc="ID of the L1 cache to forward the block to once we get a response";
    int pendingAcks,            desc="number of pending acks for invalidates during writeback";
    int waitDataNum,            desc="this is only for multi requests hit SS state that need several WB_Data";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    bool areNSlotsAvailable(int, Tick);
  }

  TBETable TBEs, template="<L2Cache_TBE>", constructor="m_number_of_TBEs";

  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  Cycles ticksToCycles(Tick t);

  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);

  // non-inclusive cache
  CacheEntry getCacheEntry(Addr addr), return_by_pointer="yes" {
    return static_cast(CacheEntry, "pointer", L2cache[addr]);
  }

  DirEntry getDirEntry(Addr addr), return_by_pointer="yes" {
    return static_cast(DirEntry, "pointer", SF[addr]);
  }

  bool isSharer(Addr addr, MachineID requestor, DirEntry dir_entry) {
    if (is_valid(dir_entry)) {
      return dir_entry.Sharers.isElement(requestor);
    } else {
      return false;
    }
  }

  bool isCacheToEvict(TBE tbe) {
    if (is_invalid(tbe)) {
      return false;
    }
    return tbe.cacheToEvict;
  }

  bool isDirToEvict(TBE tbe) {
    if (is_invalid(tbe)) {
      return false;
    }
    return tbe.dirToEvict;
  }

  void addSharer(Addr addr, MachineID requestor, DirEntry dir_entry) {
    assert(is_valid(dir_entry));
    DPRINTF(RubySlicc, "addSharer::addr=%x, sharer: %d\n"
                     ,addr, requestor);
    dir_entry.Sharers.add(requestor);
  }

  State bkDirStateSwitch(std::string sta) {
    if (sta == "NP") {
      return State:NP;
    } else if (sta == "ISS") {
      return State:ISS;
    } else if (sta == "IM") {
      return State:IM;
    } else if (sta == "MT_MB") {
      return State:MT_MB;
    } else if (sta == "MT") {
       return State:MT;
    } else if (sta == "MT_IIB") {
      return State:MT_IIB;
    } else {
      assert(false);
    }
  }

  bool isBackupStateinBusy(std::string sta, bool is_putx) {
    return (sta == "ISS"    || sta == "IM" || sta == "MT_MB" || 
            sta == "MT_IIB" || sta == "M_I"||(sta == "PUTX" && !is_putx));
  }

  State getState(TBE tbe, CacheEntry cache_entry, Addr addr) {
    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    DirEntry dir_entry := getDirEntry(addr);
    if (is_valid(dir_entry)) {
      assert(dir_entry.DirState != State:BK);
      return dir_entry.DirState;
    }
    return State:NP;
  }

  void setState(TBE tbe, CacheEntry cache_entry, Addr addr, State state) {
    // MUST CHANGE
    if (is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }

    DirEntry dir_entry := getDirEntry(addr);
    if (is_valid(dir_entry)) {
      assert(state != State:BK);
      dir_entry.DirState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s\n", L2Cache_State_to_permission(tbe.TBEState));
      return L2Cache_State_to_permission(tbe.TBEState);
    }

    CacheEntry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s\n", L2Cache_State_to_permission(cache_entry.CacheState));
      return L2Cache_State_to_permission(cache_entry.CacheState);
    }

    DirEntry dir_entry := getDirEntry(addr);
    if(is_valid(dir_entry)) {
      DPRINTF(RubySlicc, "%s\n", L2Cache_State_to_permission(dir_entry.DirState));
      return L2Cache_State_to_permission(dir_entry.DirState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    CacheEntry cache_entry := getCacheEntry(addr);
    if (is_valid(cache_entry)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, cache_entry.DataBlk, pkt);
        return num_functional_writes;
    }
    return num_functional_writes;
  }

  void setAccessPermission(CacheEntry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L2Cache_State_to_permission(state));
    }
    DirEntry dir_entry := getDirEntry(addr);
    if (is_valid(dir_entry)) {
      dir_entry.changePermission(L2Cache_State_to_permission(state));
    }
  }

  Event L1Cache_request_type_to_event(CoherenceRequestType type, Addr addr,
                                      MachineID requestor, DirEntry dir_entry, bool dirty,
                                      State state, CacheEntry cache_entry) {
    if(type == CoherenceRequestType:GETS) {
      if (state == State:SS && is_valid(cache_entry)) {
        return Event:L1_GETS_withC;
      }
      return Event:L1_GETS;
    } else if(type == CoherenceRequestType:GET_INSTR) {
      if (state == State:SS && is_valid(cache_entry)) {
        return Event:L1_GETS_withC;
      }
      return Event:L1_GET_INSTR;
    } else if (type == CoherenceRequestType:GETX) {
      return Event:L1_GETX;
    } else if (type == CoherenceRequestType:UPGRADE) {
      if ( is_valid(dir_entry) && dir_entry.Sharers.isElement(requestor) ) {
        return Event:L1_UPGRADE;
      } else {
        return Event:L1_GETX;
      }
    } else if (type == CoherenceRequestType:PUTX) {
      if (dirty) {
        return Event:L1_PUTX_front;
      } else {
        return Event:L1_PUTX_clean;
      }
    } else {
      DPRINTF(RubySlicc, "address: %#x, Request Type: %s\n", addr, type);
      error("Invalid L1 forwarded request type");
    }
  }

  Event L1Cache_request_bk_to_event(CoherenceRequestType type, Addr addr,
                                    MachineID requestor, DirEntry dir_entry, bool dirty,
                                    State state, CacheEntry cache_entry) {
    if(type == CoherenceRequestType:GETS) {
      return Event:L1_GETS_BK;
    } else if(type == CoherenceRequestType:GET_INSTR) {
      return Event:L1_GET_INSTR_BK;
    } else if (type == CoherenceRequestType:GETX) {
      return Event:L1_GETX_BK;
    } else if (type == CoherenceRequestType:PUTX) {
      if (dirty) {
        return Event:L1_PUTX_front_BK;
      } else {
        return Event:L1_PUTX_clean_BK;
      }
    } else if (type == CoherenceRequestType:UPGRADE) {
      return Event:L1_UPGRADE_BK;
    } else {
      DPRINTF(RubySlicc, "address: %#x, Request Type: %s\n", addr, type);
      error("Invalid L1 forwarded request type");
    }
  }

  Event L1Cache_request_to_l2_to_event(CoherenceRequestType type, Addr addr,
                                    MachineID requestor, DirEntry dir_entry, bool dirty,
                                    State state, CacheEntry cache_entry) {
    if(type == CoherenceRequestType:GETS) {
      return Event:L1_GETS_BKL2;
    } else if(type == CoherenceRequestType:GET_INSTR) {
      return Event:L1_GET_INSTR_BKL2;
    } else if (type == CoherenceRequestType:GETX) {
      return Event:L1_GETX_BKL2;
    } else if (type == CoherenceRequestType:PUTX) {
      if (L2cache.isDirBackupL2(addr)) {
        return Event:L1_PUTX_BKL2;
      } else {
        if (dirty) {
          return Event:L1_PUTX_front_BK;
        } else {
          return Event:L1_PUTX_clean_BK;
        }
      }
    } else if (type == CoherenceRequestType:UPGRADE) {
      return Event:L1_UPGRADE_BKL2;
    } else {
      DPRINTF(RubySlicc, "address: %#x, Request Type: %s\n", addr, type);
      error("Invalid L1 forwarded request type");
    }
  }

  int getPendingAcks(TBE tbe) {
    if (is_invalid(tbe)) {
      return 0;
    }
    return tbe.pendingAcks;
  }

  bool isDirty(CacheEntry cache_entry) {
    if(is_invalid(cache_entry)) {
      return false;
    }
    return cache_entry.Dirty;
  }

  bool isDirWaitEvict(DirEntry dir_entry) {
    if(is_invalid(dir_entry)) {
      return false;
    }
    return dir_entry.waitEvict;
  }

  // ** OUT_PORTS **

  out_port(L1RequestL2Network_out, RequestMsg, L1RequestFromL2Cache);
  out_port(DirRequestL2Network_out, RequestMsg, DirRequestFromL2Cache);
  out_port(responseL2Network_out, ResponseMsg, responseFromL2Cache);
  out_port(triggerOutPort, RequestMsg, TriggerPort);


  in_port(L1unblockNetwork_in, ResponseMsg, unblockToL2Cache, rank = 3) {
    if(L1unblockNetwork_in.isReady(clockEdge())) {
      peek(L1unblockNetwork_in,  ResponseMsg) {
        CacheEntry cache_entry := getCacheEntry(in_msg.addr);
        DirEntry   dir_entry   := getDirEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        State state := getState(tbe, cache_entry, in_msg.addr);
        DPRINTF(RubySlicc, "L1unblockNetwork_in::addr=%x State: %s Sender: %s Type: %s\n"
                         ,in_msg.addr, state, in_msg.Sender, in_msg.Type);

        assert(in_msg.Destination.isElement(machineID));
        if (in_msg.Type == CoherenceResponseType:EXCLUSIVE_UNBLOCK) {
          trigger(Event:Exclusive_Unblock, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceResponseType:UNBLOCK) {
          if (state == State:MT_SB && is_valid(tbe)) {
            assert(tbe.waitDataNum > 0);
            if (tbe.waitDataNum > 1) {
              DPRINTF(RubySlicc, "L1unblockNetwork_in::keep MT_SB state\n");
              tbe.waitDataNum := tbe.waitDataNum - 1;
              assert(false); // disable waitDataNum because SS cannot share data 
                             // to two requestors at the same time
              trigger(Event:Unblock_Keep, in_msg.addr, cache_entry, tbe);
            }
          }
          trigger(Event:Unblock, in_msg.addr, cache_entry, tbe);
        } else {
          error("unknown unblock message");
        }
      }
    }
  }

  // Response  L2 Network - response msg to this particular L2 bank
  in_port(responseL2Network_in, ResponseMsg, responseToL2Cache, rank = 2) {
    if (responseL2Network_in.isReady(clockEdge())) {
      peek(responseL2Network_in, ResponseMsg) {
        // test wether it's from a local L1 or an off chip source
        assert(in_msg.Destination.isElement(machineID));
        CacheEntry cache_entry := getCacheEntry(in_msg.addr);
        DirEntry   dir_entry   := getDirEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        State state := getState(tbe, cache_entry, in_msg.addr);
        DPRINTF(RubySlicc, "responseL2Network_in::addr=%x State: %s Sender: %s Type: %s ackcount=%d cachetoEvict=%d, dirToEvict=%d\n",
                in_msg.addr, state, in_msg.Sender, in_msg.Type, in_msg.AckCount, isCacheToEvict(tbe), isDirToEvict(tbe));

        if(machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {
          if (isDirToEvict(tbe)) {
            assert(in_msg.AckCount < 2);
            // is the directory back invalidation
            if(getPendingAcks(tbe) > 1) {
              if (in_msg.Type == CoherenceResponseType:DATA && in_msg.Dirty) {
                if (state == State:I_I && isCacheToEvict(tbe) && !L2cache.cacheAvail(in_msg.addr)) {
                    // here is the situation that directory eviction
                    // encounter cache eviction, we deallocate cache
                    // entry first and set state to I_I. However, the
                    // directory EV creates back invalidation. Therefore,
                    // we do not allocate this cache entry again when
                    // cache is unavailable
                    // MAYBE FAULT!!
                  trigger(Event:WB_Data_Keep, in_msg.addr, cache_entry, tbe);
                }
                //trigger(Event:WB_Data, in_msg.addr, cache_entry, tbe);
                trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
              } else {
                trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
              }
            } else {
              assert(getPendingAcks(tbe) == 1);
              if ((in_msg.Type == CoherenceResponseType:DATA && in_msg.Dirty) ||
                   tbe.dataBackInvalid) { // need to allocate cache
                if (state == State:I_I && isCacheToEvict(tbe) && !L2cache.cacheAvail(in_msg.addr)) {
                  // MAYBE FAULT!!
                  trigger(Event:Ack_all_DtoMem, in_msg.addr, cache_entry, tbe);
                }

                if (L2cache.cacheAvail(in_msg.addr)) {
                  // allocate back invalidate data
                  trigger(Event:WB_Data_all, in_msg.addr, cache_entry, tbe);

                } else {
                  // cache evict
                  Addr victim := L2cache.cacheProbe(in_msg.addr);
                  CacheEntry L2cache_entry := getCacheEntry(victim);
                  TBE tbe_victim := TBEs[victim];
                  State victim_state := getState(tbe_victim, L2cache_entry, victim);
                  DPRINTF(RubySlicc, "responseL2Network_in::Cache victim::addr=%x, victim=%x, victim state=%d\n"
                                   , in_msg.addr, victim, victim_state);
                  enqueue(triggerOutPort, RequestMsg, 0) {
                    out_msg.addr := victim;
                    out_msg.Type := CoherenceRequestType:EVC;
                    out_msg.DataBlk := L2cache_entry.DataBlk;
                    out_msg.Dirty := L2cache_entry.Dirty;
                    out_msg.Len := 2;
                  }
                  tbe.hasprofileBIDirty := true;
                  L2cache_entry.aheadAllocate := true;
                  L2cache_entry.aheadAddr := in_msg.addr;
                  // set MRU to stop replacement twice
                  L2cache.setMRU(victim);
                  stall_and_wait(responseL2Network_in, victim);
                }
              } else {
                trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
              }
            }
          } else {
            if(in_msg.Type == CoherenceResponseType:DATA) {
              if (in_msg.Dirty) {
                trigger(Event:WB_Data, in_msg.addr, cache_entry, tbe);
              } else {
                trigger(Event:WB_Data_clean, in_msg.addr, cache_entry, tbe);
              }
            } else if (in_msg.Type == CoherenceResponseType:ACK) {
              if ((getPendingAcks(tbe) - in_msg.AckCount) == 0) {
                trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
              } else {
                trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
              }
            } else {
              error("unknown message type");
            }
          }

        } else { // external message
          if(in_msg.Type == CoherenceResponseType:MEMORY_DATA) {
            if (state == State:BK) {
              State bk_state := bkDirStateSwitch(L2cache.getbkDirState(in_msg.addr));
              if (bk_state == State:ISS) {
                trigger(Event:Mem_Data_ISS, in_msg.addr, cache_entry, tbe);
              } else if (bk_state == State:IM) {
                trigger(Event:Mem_Data_IM, in_msg.addr, cache_entry, tbe);
              }
            }
            trigger(Event:Mem_Data, in_msg.addr, cache_entry, tbe);
          } else if(in_msg.Type == CoherenceResponseType:MEMORY_ACK) {
            if (is_valid(tbe)) {
              if (isCacheToEvict(tbe) && is_valid(dir_entry)) {
                if (dir_entry.Sharers.count() == 1) {
                  trigger(Event:Mem_Ack_MT, in_msg.addr, cache_entry, tbe);
                }
                assert(dir_entry.Sharers.count() > 1);
                trigger(Event:Mem_Ack_SS, in_msg.addr, cache_entry, tbe);
              }
            }
            if (state == State:BK) { 
              if (L2cache.getbkDirState(in_msg.addr) == "ISS" || L2cache.getbkDirState(in_msg.addr) == "IM") {
                trigger(Event:Mem_Ack_No_deallocTBE, in_msg.addr, cache_entry, tbe);
              }
              if (L2cache.getbkDirState(in_msg.addr) == "M_I") {
                trigger(Event:Mem_Ack_MT, in_msg.addr, cache_entry, tbe);
              }
            }
            trigger(Event:Mem_Ack, in_msg.addr, cache_entry, tbe);
          } else if(in_msg.Type == CoherenceResponseType:INV) {
            trigger(Event:MEM_Inv, in_msg.addr, cache_entry, tbe);
          } else {
            error("unknown message type");
          }
        }
      }
    }  // if not ready, do nothing
  }

  // cache replacement port
  in_port(triggerInPort, RequestMsg, TriggerPort, rank=1) {
    if(triggerInPort.isReady(clockEdge())) {
      peek(triggerInPort, RequestMsg) {
        CacheEntry cache_entry := getCacheEntry(in_msg.addr);
        DirEntry   dir_entry   := getDirEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        State state := getState(tbe, cache_entry, in_msg.addr);
        DPRINTF(RubySlicc, "triggerInPort::addr=%x, cache dirty=%d State: %s Req: %s Type: %s\n"
                         , in_msg.addr, isDirty(cache_entry), state, in_msg.Requestor, in_msg.Type);

        if (in_msg.addr == debugAddr) {
          DPRINTF(TraceTrackerLLC, "triggerInPort::addr=%x, cache dirty=%d State: %s Req: %s Type: %s\n"
                                , in_msg.addr, isDirty(cache_entry), state, in_msg.Requestor, in_msg.Type);
        }

        if (in_msg.Type == CoherenceRequestType:EVC) {
          assert(is_valid(cache_entry));
          trigger(Event:L2_Replacement, in_msg.addr, cache_entry, tbe);

        } else if (in_msg.Type == CoherenceRequestType:EVC_DIR) {
          CacheEntry L2cache_entry := getCacheEntry(in_msg.addr);
          DirEntry dir_victim_entry := getDirEntry(in_msg.addr);
          TBE tbe_victim := TBEs[in_msg.addr];
          // it is possible that dir has been evicted twice
          assert(is_valid(dir_victim_entry));

          if (is_invalid(L2cache_entry)) {
            trigger(Event:SF_Replacement, in_msg.addr, L2cache_entry, TBEs[in_msg.addr]);
          } else {
            trigger(Event:SF_Replacement_withC, in_msg.addr, L2cache_entry, TBEs[in_msg.addr]);
          }

        } else if (in_msg.Type == CoherenceRequestType:SW_DIR) {
          assert(is_valid(dir_entry));
          trigger(Event:SF_Switch, in_msg.addr, cache_entry, tbe);

        } else {
          assert(in_msg.Type == CoherenceRequestType:PUTX);
          assert(in_msg.Dirty);
          DPRINTF(RubySlicc, "triggerInPort::is PUTX::addr=%x, State: %s Req: %s\n"
                           , in_msg.addr, state, in_msg.Requestor);
          if (state == State:SS || state == State:MT) {
            assert(is_valid(dir_entry));
            if (dir_entry.Sharers.count() > 2) {
              trigger(Event:L1_PUTX_end_toSS, in_msg.addr, cache_entry, tbe);
            } else if (dir_entry.Sharers.count() == 2) {
              if (state == State:SS && !dir_entry.Sharers.isElement(in_msg.Requestor)) {
                // PUTX encounters back invalid
                // set state to be SS instead of MT
                trigger(Event:L1_PUTX_end_toSS, in_msg.addr, cache_entry, tbe);
              }
              trigger(Event:L1_PUTX_end_toMT, in_msg.addr, cache_entry, tbe);
            } else if (dir_entry.Sharers.count() == 1 && state == State:MT &&
                      !dir_entry.Sharers.isElement(in_msg.Requestor)) {
              trigger(Event:L1_PUTX_end_toMT, in_msg.addr, cache_entry, tbe);
            }
          }
          // to M state
          trigger(Event:L1_PUTX_end, in_msg.addr, cache_entry, tbe);
        }
      }
    }
  }
  // use directory instead of cache to deter allocating LLC 
  in_port(L1RequestL2Network_in, RequestMsg, L1RequestToL2Cache, rank = 0) {
    if(L1RequestL2Network_in.isReady(clockEdge()) && TBEs.areNSlotsAvailable(2,clockEdge())) {
      peek(L1RequestL2Network_in,  RequestMsg) {
        CacheEntry cache_entry := getCacheEntry(in_msg.addr);
        DirEntry   dir_entry   := getDirEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        State state := getState(tbe, cache_entry, in_msg.addr);

        DPRINTF(RubySlicc, "L1RequestL2Network_in::addr=%x State: %s Req: %s Type: %s, cache dirty=%d, req dirty=%d\n",
                in_msg.addr, state, in_msg.Requestor, in_msg.Type, isDirty(cache_entry), in_msg.Dirty);

        if (in_msg.addr == debugAddr) {
          DPRINTF(TraceTrackerLLC, "L1RequestL2Network_in::addr=%x State: %s Req: %s Type: %s, cache dirty=%d, req dirty=%d\n",
                  in_msg.addr, state, in_msg.Requestor, in_msg.Type, isDirty(cache_entry), in_msg.Dirty);
        }

        assert(machineIDToMachineType(in_msg.Requestor) == MachineType:L1Cache);
        assert(in_msg.Destination.isElement(machineID));

        if (is_valid(dir_entry)) {
          // counter
          SF.profileDemandHit();
          // check wait evict flag
          if (in_msg.Type == CoherenceRequestType:GETX && isDirWaitEvict(dir_entry)) {
            trigger(Event:Pend, in_msg.addr, cache_entry, tbe);
          }
          // The SF contains the block, so proceeded with handling the request
          if (in_msg.Type == CoherenceRequestType:PUTX && !in_msg.Dirty &&
             (state == State:SS || state == State:MT) &&
              dir_entry.Sharers.count() == 1 ) {
            // it is possible that putx stall by upgrade, and the sharers
            // has been removed, so that delete assert check and silent
            // move to original state
            // assert(dir_entry.Sharers.isElement(in_msg.Requestor));
            if (!dir_entry.Sharers.isElement(in_msg.Requestor)) {
              trigger(Event:L1_PUTX_clean_pop, in_msg.addr, cache_entry, tbe);
            }
            // this is the situation that PUTX is clean data and need
            // to deallocate directory, we let SS state turns to M or NP
            if (is_valid(cache_entry)) {
              trigger(Event:L1_PUTX_clean_toM, in_msg.addr, cache_entry, tbe);
            } else {
              trigger(Event:L1_PUTX_clean_toNP, in_msg.addr, cache_entry, tbe);
            }
          }
          trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                state, cache_entry),
                  in_msg.addr, cache_entry, tbe);
        
        } else if (L2cache.isDirinBackup(in_msg.addr)) {
          // counter
          bool needRecover := L2cache.getOwnerinBackup(in_msg.addr) != in_msg.Requestor;
          SF.profileDemandHitCache(needRecover);
          // directory access hit in cache
          // needs to receive dir tag in dir
          DPRINTF(RubySlicc, "L1RequestL2Network_in::directory hits in cache::addr=%x, state=%d, Type=%d, Dirty=%d, backupstate=%s, backupowner=%d\n"
                           , in_msg.addr, state, in_msg.Type, in_msg.Dirty, L2cache.getbkDirState(in_msg.addr), L2cache.getOwnerinBackup(in_msg.addr));
          assert(state == State:BK);

          /////////////////// New Implement//////////////////////////
          ///// Backup Directory to L2 if sharing happens////////////
          ///////////////////////////////////////////////////////////
          if (backup_L2_en && (needRecover || in_msg.Type == CoherenceRequestType:PUTX || 
                                              in_msg.Type == CoherenceRequestType:UPGRADE)) {
            DPRINTF(RubySlicc, "L1RequestL2Network_in::backup to L2::addr=%x\n"
                             , in_msg.addr);
            assert(is_invalid(cache_entry));
            if (isBackupStateinBusy(L2cache.getbkDirState(in_msg.addr), in_msg.Type == CoherenceRequestType:PUTX)) {
              // may be stall by other access
              trigger(Event:Pend, in_msg.addr, cache_entry, tbe);
            }
            trigger(L1Cache_request_to_l2_to_event(in_msg.Type, in_msg.addr,
                                                   in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                   state, cache_entry),
                        in_msg.addr, cache_entry, tbe);
          }

          if (in_msg.Type == CoherenceRequestType:PUTX || 
              in_msg.Type == CoherenceRequestType:UPGRADE ||
             (SF.cacheAvail(in_msg.addr) && needRecover)) {
            
            if (isBackupStateinBusy(L2cache.getbkDirState(in_msg.addr), in_msg.Type == CoherenceRequestType:PUTX)) {
              // may be stall by other access
              trigger(Event:Pend, in_msg.addr, cache_entry, tbe);
            }
            trigger(L1Cache_request_bk_to_event(in_msg.Type, in_msg.addr,
                                                in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                state, cache_entry),
                        in_msg.addr, cache_entry, tbe);
          } else {
            // DirinBackup need recover to directory, which is not available
            Addr victim := SF.cacheProbe(in_msg.addr);
            CacheEntry L2cache_entry := getCacheEntry(victim);
            DirEntry dir_victim_entry := getDirEntry(victim);
            TBE tbe_victim := TBEs[victim];
            State victim_state := getState(tbe_victim, L2cache_entry, victim);
            if (!SF.isTagPresent(victim) || SF.cacheBlock(in_msg.addr)) {
              // this means the current SF set has been pending full
              // so that is not available
              DPRINTF(RubySlicc, "L1RequestL2Network_in::backup::directory block when recover::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                               , in_msg.addr, state, victim,victim_state, is_valid(L2cache_entry));
              stall_and_wait(L1RequestL2Network_in, victim);
              trigger(Event:Pop_ReqIn, in_msg.addr, cache_entry, tbe);
            }
            assert(is_valid(dir_victim_entry));
            // set to evcit flag
            DPRINTF(RubySlicc, "L1RequestL2Network_in::backup::directory replacement::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                             , in_msg.addr, state, victim, victim_state, is_valid(L2cache_entry));
            if (in_msg.addr == debugAddr) {
              DPRINTF(TraceTrackerLLC, "L1RequestL2Network_in::backup::directory replacement::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                              , in_msg.addr, state, victim, victim_state, is_valid(L2cache_entry));
            }

            if (dir_victim_entry.Sharers.count() == 1 && (victim_state == State:MT || victim_state == State:M_I || victim_state == State:SS) &&
                is_invalid(L2cache_entry) && L2cache.isFreetoBackup(victim)) {
              // directory has only one sharers, so that we switch it to cache as back up
              // may need cache evict for the directory entry switched
              Addr cache_victim := L2cache.cacheProbetoBk(victim);
              if (cache_victim == -1) {
                enqueue(triggerOutPort, RequestMsg, 0) {
                  out_msg.addr := victim;
                  out_msg.Type := CoherenceRequestType:SW_DIR;
                }
                // set MRU to prevent this address being evicted twice
                SF.setMRU(victim);

              } else {
                // assert(false);
                CacheEntry L2cache_entry_victim := getCacheEntry(cache_victim);
                assert(is_valid(L2cache_entry_victim));
                TBE cache_tbe_victim := TBEs[cache_victim];
                State cache_victim_state := getState(cache_tbe_victim, L2cache_entry_victim, cache_victim);
                DPRINTF(RubySlicc, "L1RequestL2Network_in::directory switch creates cache eviction::victim addr=%x, victim state=%d\n"
                                , cache_victim, cache_victim_state);
                enqueue(triggerOutPort, RequestMsg, 0) {
                  out_msg.addr := cache_victim;
                  out_msg.Type := CoherenceRequestType:EVC;
                  out_msg.AccessMode := in_msg.AccessMode;
                  out_msg.MessageSize := in_msg.MessageSize;
                  out_msg.DataBlk := L2cache_entry_victim.DataBlk;
                  out_msg.Dirty := L2cache_entry_victim.Dirty;
                  out_msg.Len := 1;
                }
                if (cache_victim_state != State:SS && cache_victim_state != State:M && 
                    cache_victim_state != State:MT && cache_victim_state != State:S_I) {
                  assert(false);
                }
              }

            } else {
              // directory eviction
              stall_and_wait(L1RequestL2Network_in, victim);
              // savePendingAddr
              SF.savePendingAddr(in_msg.addr, in_msg.Requestor);
              // insert to trigger port
              enqueue(triggerOutPort, RequestMsg, 0) {
                out_msg.addr := victim;
                out_msg.Type := CoherenceRequestType:EVC_DIR;
              }
              // set MRU to prevent this address being evicted twice
              SF.setMRU(victim);
              // profile eviction from repair
              SF.profileEvictionfromRepair();
            }
          }

        } else {
          if (SF.cacheAvail(in_msg.addr)) {
            // it is possible that the address has been stalled
            // by the other request, the cacheavail checks just hit
            // the pending address, we need to stall it again
            if ((SF.cacheFullbuthasPend(in_msg.addr) || SF.cachehasOtherPend(in_msg.addr, in_msg.Requestor)) && 
               (state == State:M || state == State:NP)) {
              DPRINTF(RubySlicc, "L1RequestL2Network_in::directory has stall::addr=%x, state=%d\n"
                               , in_msg.addr, state);
              trigger(Event:Pend, in_msg.addr, cache_entry, tbe);
            }
            // counter
            SF.profileDemandMiss();
            // SF does't have the line, but we have space for it in the SF
            trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                  in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                  state, cache_entry),
                    in_msg.addr, cache_entry, tbe);

          } else if (L2cache.isFreetoBackup(in_msg.addr)) {
            // but PUTX doesnot need to allocate directory
            if (in_msg.Type == CoherenceRequestType:PUTX) {
              trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                    in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                    state, cache_entry),
                      in_msg.addr, cache_entry, tbe);
            }
            // cache back
            // Addr cache_victim := L2cache.cacheProbetoBk(in_msg.addr, new CacheEntry);
            Addr cache_victim := L2cache.cacheProbetoBk(in_msg.addr);
            if (cache_victim == -1) {
              // need not to deallocate cache line
              DPRINTF(RubySlicc, "L1RequestL2Network_in::directory will back to cache::addr=%x, state=%d\n"
                               , in_msg.addr, state);
              trigger(L1Cache_request_bk_to_event(in_msg.Type, in_msg.addr,
                                                  in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                  state, cache_entry),
                      in_msg.addr, cache_entry, tbe);
            }
            // assert(false);//TODO: evict cache line
            CacheEntry L2cache_entry := getCacheEntry(cache_victim);
            assert(is_valid(L2cache_entry));
            TBE tbe_victim := TBEs[cache_victim];
            State victim_state := getState(tbe_victim, L2cache_entry, cache_victim);
            DPRINTF(RubySlicc, "L1RequestL2Network_in::directory backup creates cache eviction::victim addr=%x, victim state=%d\n"
                             , cache_victim, victim_state);
            enqueue(triggerOutPort, RequestMsg, 0) {
              out_msg.addr := cache_victim;
              out_msg.Type := CoherenceRequestType:EVC;
              out_msg.AccessMode := in_msg.AccessMode;
              out_msg.MessageSize := in_msg.MessageSize;
              out_msg.DataBlk := L2cache_entry.DataBlk;
              out_msg.Dirty := L2cache_entry.Dirty;
              out_msg.Len := 1;
            }
            if (victim_state != State:SS && victim_state != State:M && 
                victim_state != State:MT && victim_state != State:S_I) {
              assert(false);
            }

          } else {
            // No room in the SF, so we need to make room before handling the request
            // but PUTX doesnot need to allocate directory
            if (in_msg.Type == CoherenceRequestType:PUTX) {
              trigger(L1Cache_request_type_to_event(in_msg.Type, in_msg.addr,
                                                    in_msg.Requestor, dir_entry, in_msg.Dirty,
                                                    state, cache_entry),
                      in_msg.addr, cache_entry, tbe);
            }
            Addr victim := SF.cacheProbe(in_msg.addr);
            CacheEntry L2cache_entry := getCacheEntry(victim);
            DirEntry dir_victim_entry := getDirEntry(victim);
            TBE tbe_victim := TBEs[victim];
            if (!SF.isTagPresent(victim) || SF.cacheBlock(in_msg.addr)) {
              // this means the current SF set has been pending full
              // so that is not available
              DPRINTF(RubySlicc, "L1RequestL2Network_in::directory block::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                               , in_msg.addr, state, victim, getState(tbe_victim, L2cache_entry, victim), is_valid(L2cache_entry));
              stall_and_wait(L1RequestL2Network_in, victim);
              trigger(Event:Pop_ReqIn, in_msg.addr, cache_entry, tbe);
            }
            assert(is_valid(dir_victim_entry));
            // set to evcit flag
            DPRINTF(RubySlicc, "L1RequestL2Network_in::directory replacement::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                             , in_msg.addr, state, victim, getState(tbe_victim, L2cache_entry, victim), is_valid(L2cache_entry));
            if (in_msg.addr == debugAddr) {
              DPRINTF(TraceTrackerLLC, "L1RequestL2Network_in::directory replacement::addr=%x, state=%d, victim=%x, state=%d, cache valid=%d\n"
                              , in_msg.addr, state, victim, getState(tbe_victim, L2cache_entry, victim), is_valid(L2cache_entry));
            }

            stall_and_wait(L1RequestL2Network_in, victim);
            // savePendingAddr
            SF.savePendingAddr(in_msg.addr, in_msg.Requestor);
            // insert to trigger port
            enqueue(triggerOutPort, RequestMsg, 0) {
              out_msg.addr := victim;
              out_msg.Type := CoherenceRequestType:EVC_DIR;
            }
            // set MRU to prevent this address being evicted twice
            SF.setMRU(victim);
          }
        }
      }
    }
  }

  bool needAllocateCache(State state, Addr addr, CacheEntry cache_entry) {
    DirEntry dir_entry := getDirEntry(addr);
    if(L1RequestL2Network_in.isReady(clockEdge()) && is_valid(dir_entry) && is_invalid(cache_entry)) {
      peek(L1RequestL2Network_in, RequestMsg) {
        DPRINTF(RubySlicc, "needAllocateCache::addr=%x, type=%d, state=%d, diff requestor=%d\n"
                         , addr, in_msg.Type, state, !dir_entry.Sharers.isElement(in_msg.Requestor));
        return (in_msg.Type == CoherenceRequestType:GETS ||
                in_msg.Type == CoherenceRequestType:GET_INSTR) &&
               (state == State:MT || state == State:SS || state == State:ISS ||
                state == State:IS);
      }
    }
    return false;
  }

  ////////////////////////////////
  // include//
  include "MESI_Two_Level-L2cache-actions.sm";
}
